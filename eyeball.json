{:abstract
 "In computing, s-expressions, sexprs or sexps (for \"symbolic expression\") are a notation for nested list (tree-structured) data, invented for and popularized by the programming language Lisp, which uses them for source code as well as data. In the usual parenthesized syntax of Lisp, an s-expression is classically defined inductively as\nan atom, or\nan expression of the form (x . y) where x and y are s-expressions.\nThe second, recursive part of the definition represents an ordered pair so that s-exprs are effectively binary trees.\nThe definition of an atom varies per context; in the original definition by John McCarthy, it was assumed that there existed \"an infinite set of distinguishable atomic symbols\" represented as \"strings of capital Latin letters and digits with single embedded blanks\" (i.e., character string and numeric literals). Most modern sexpr notations in addition use an abbreviated notation to represent lists in s-expressions, so that\n(x y z)\nstands for\n(x . (y . (z . NIL)))\nwhere NIL is the special end-of-list symbol (written '() in Scheme).\nIn the Lisp family of programming languages, s-expressions are used to represent both source code and data. Other uses of S-expressions are in Lisp-derived languages such as DSSSL, and as mark-up in communications protocols like IMAP and John McCarthy's CBCL. The details of the syntax and supported data types vary in the different languages, but the most common feature among these languages is the use of S-expressions and prefix notation.\n\n\n",
 :sections
 [{:sections
   [{:text
     "Nested lists can be written as S-expressions: ((milk juice) (honey marmalade)) is a two-element S-expression whose elements are also two-element S-expressions. The whitespace-separated notation used in Lisp (and this article) is typical. Line breaks (newline characters) usually qualify as separators.\nThis is a simple context-free grammar for a tiny subset of English written as an s-expression (Gazdar/Melish, Natural Language Processing in Lisp):\n\n\n",
     :title " Examples of data s-expressions "}
    {:text
     "Program code can be written in S-expressions, usually using prefix notation.\nExample in Common Lisp:\n\nS-expressions can be read in Lisp using the function READ. READ reads the textual representation of an s-expression and returns Lisp data. The function PRINT can be used to output an s-expression. The output then can be read with the function READ, when all printed data objects have a readable representation. Lisp has readable representations for numbers, strings, symbols, lists and many other data types. Program code can be formatted as pretty printed S-expressions using the function PPRINT (note: with two Ps, short for pretty-print).\nLisp programs are valid s-expressions, but not all s-expressions are valid Lisp programs. (1.0 + 3.1) is a valid s-expression, but not a valid Lisp program, since Lisp uses prefix notation and a floating point number (here 1.0) is not valid as an operation (the first element of the expression).\nAn S-expression preceded by a single quotation mark, as in 'x, is syntactic sugar for a quoted S-expression, in this case (quote x).\n\n\n",
     :title " Example of source code s-expressions "}],
   :text
   "When representing source code in Lisp, the first element of an S-expression is commonly an operator or function name and any remaining elements are treated as arguments. This is called \"prefix notation\" or \"Cambridge Polish notation\". As an example, the Boolean expression written 4 == (2 + 2) in C is represented as (= 4 (+ 2 2)) in Lisp's s-expr-based prefix notation.\nAs noted above, the precise definition of \"atom\" varies across LISP-like languages. A quoted string can typically contain anything but a quote, while an unquoted identifier atom can typically contain anything but quote, whitespace characters, parenthesis, brackets, braces, backslash, and semicolon. In either case, a prohibited character can typically be included by escaping it with a preceding backslash. Unicode support varies.\nThe recursive case of the s-expr definition is traditionally implemented using cons cells.\nS-expressions were originally intended only for data to be manipulated by M-expressions, but the first implementation of Lisp was an interpreter of S-expression encodings of M-expressions, and Lisp programmers soon became accustomed to using S-expressions for both code and data. This means that Lisp is homoiconic, that is, the primary representation of programs is also a data structure in a primitive type of the language itself.\n\n\n",
   :title " Use in Lisp "}
  {:text
   "Standards for some Lisp-derived programming languages include a specification for their S-expression syntax. These include Common Lisp (ANSI standard document ANSI INCITS 226-1994 (R2004)), Scheme (R5RS and R6RS), and ISLISP.\nIn May 1997, Ron Rivest submitted an Internet-Draft to be considered for publication as an RFC. The draft defined a syntax based on Lisp S-expressions but intended for general-purpose data storage and exchange (similar to XML) rather than specifically for programming. It was never approved as an RFC, but it has since been cited and used by other RFCs (e.g. RFC 2693) and several other publications. It was originally intended for use in SPKI.\nRivest's format defines an S-expression as being either an octet-string (a series of bytes) or a finite list of other S-expressions. It describes three interchange formats for expressing this structure. One is the \"advanced transport\", which is very flexible in terms of formatting, and is syntactically similar to Lisp-style expressions, but they are not identical. The advanced transport, for example, allows octet-strings to be represented verbatim (the string's length followed by a colon and the entire raw string), a quoted form allowing escape characters, hexadecimal, Base64, or placed directly as a \"token\" if it meets certain conditions. (Rivest's tokens differ from Lisp tokens in that the former are just for convenience and aesthetics, and treated exactly like other strings, while the latter have specific syntactical meaning.) Another interchange format, intended to be more compact, easier to parse, and unique for any abstract S-expression, is the \"canonical representation\" which only allows verbatim strings, and prohibits whitespace as formatting outside strings. Finally there is the \"basic transport representation\", which is either the canonical form or the same encoded as Base64 and surrounded by braces, the latter intended to safely transport a canonically encoded S-expression in a system which might change spacing (e.g. an email system which has 80-character-wide lines and wraps anything longer than that).\nThis format has not been widely adapted for use outside of SPKI. Rivest's S-expressions web page provides C source code for a parser and generator (available under the MIT license, which could be adapted and embedded into other programs. In addition, there are no restrictions on independently implementing the format.\n\n\n",
   :title " Standardization "}
  {:text
   "M-expression\ncar and cdr\ncons\nCanonical S-expressions\nComparison of data serialization formats\n\n\n",
   :title " See also "}
  {:text "\n\n", :title " References "}
  {:text
   "Free software implementations are available:\nsfsexp the small, fast s-expression library for C/C++ on Sourceforge\nminilisp, by LÃ©on Bottou.\nlibcurie, a small libc replacement that heavily relies on S-expressions.\nS-Expressions on Rosettacode has implementations of readers and writers in many languages.\n",
   :title " External links "}],
 :depiction
 "http://upload.wikimedia.org/wikipedia/commons/thumb/1/11/S-expression_tree.svg/9999px-S-expression_tree.svg.png",
 :other-langs ["es" "fi" "fr" "it" "ja" "ko" "ru" "zh"],
 :lang "en",
 :pageid 54458,
 :title "S-expression",
 :url "http://en.wikipedia.org/wiki/S-expression"}
